rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    function hasRole(role) {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }
    
    function isAdminOrOwner(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    function isValidEmail(email) {
      return email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }
    
    function isValidString(text, minLen, maxLen) {
      return text is string && 
             text.size() >= minLen && 
             text.size() <= maxLen;
    }
    
    function hasRequiredFields(fields, requiredFields) {
      return requiredFields.toSet().hasAll(fields.keys());
    }
    
    function isValidDate(date) {
      return date is timestamp || 
             (date is string && date.matches('^\\d{4}-\\d{2}-\\d{2}$'));
    }
    
    // Validate family tree data
    function isValidFamilyTree(data) {
      return hasRequiredFields(data, ['name', 'createdBy', 'createdAt']) &&
             isValidString(data.name, 1, 100) &&
             data.createdBy == request.auth.uid &&
             data.createdAt is timestamp;
    }
    
    // Validate person data
    function isValidPerson(data) {
      return hasRequiredFields(data, ['firstName', 'lastName', 'gender']) &&
             isValidString(data.firstName, 1, 100) &&
             isValidString(data.lastName, 1, 100) &&
             data.gender in ['male', 'female', 'other'] &&
             (!('email' in data) || data.email == '' || isValidEmail(data.email)) &&
             (!('birthDate' in data) || isValidDate(data.birthDate)) &&
             (!('deathDate' in data) || isValidDate(data.deathDate)) &&
             (!('biography' in data) || isValidString(data.biography, 0, 5000)) &&
             (!('audioStoryUrl' in data) || data.audioStoryUrl == '' || isValidString(data.audioStoryUrl, 0, 500)) &&
             (!('audioStoryTitle' in data) || data.audioStoryTitle == '' || isValidString(data.audioStoryTitle, 0, 200)) &&
             (!('audioStoryDate' in data) || data.audioStoryDate is timestamp);
    }
    
    // Check if user is family tree member
    function isFamilyMember(treeId) {
      let tree = get(/databases/$(database)/documents/familyTrees/$(treeId));
      return isAuthenticated() && 
             tree != null &&
             (tree.data.createdBy == request.auth.uid ||
              tree.data.ownerId == request.auth.uid ||
              request.auth.uid in tree.data.memberIds ||
              request.auth.uid in tree.data.viewers);
    }
    
    // Rate limiting helper (simplified - in production use Firebase Extensions)
    function isRateLimited() {
      // This is a placeholder - implement proper rate limiting
      return false;
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if isAdminOrOwner(userId) ||
                    // TEMPORARY: Allow reading users for setup tool
                    // Remove this after setting up your first admin!
                    (resource.data.email == 'claude@humanlevel.ai');
      
      allow create: if isOwner(userId) &&
                      hasRequiredFields(request.resource.data, ['email', 'createdAt']) &&
                      isValidEmail(request.resource.data.email) &&
                      request.resource.data.createdAt == request.time;
      
      allow update: if (isOwner(userId) &&
                      (!request.resource.data.diff(resource.data).hasAny(['email', 'createdAt', 'role', 'isAdmin'])) &&
                      (!('displayName' in request.resource.data) || 
                       isValidString(request.resource.data.displayName, 1, 100)) &&
                      (!('fullName' in request.resource.data) || 
                       isValidString(request.resource.data.fullName, 1, 100)) &&
                      (!('country' in request.resource.data) || 
                       isValidString(request.resource.data.country, 0, 100)) &&
                      (!('language' in request.resource.data) || 
                       request.resource.data.language in ['en', 'ht', 'fr']) &&
                      (!('onboardingComplete' in request.resource.data) || 
                       request.resource.data.onboardingComplete is bool) &&
                      (!('onboardingData' in request.resource.data) || 
                       request.resource.data.onboardingData is map) &&
                      (!('onboardingProgress' in request.resource.data) || 
                       request.resource.data.onboardingProgress is map)) ||
                      (isAdmin() && // Admins can update any user including role/isAdmin
                       (!('uid' in request.resource.data) || request.resource.data.uid == userId) &&
                       (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)) ||
                      // TEMPORARY: Allow setup tool to promote users to admin
                      // Remove this rule after setting up your first admin!
                      (request.resource.data.diff(resource.data).hasOnly(['role', 'isAdmin', 'adminPromotedAt', 'adminPromotedBy']) &&
                       request.resource.data.adminPromotedBy == 'setup-tool');
      
      allow delete: if isAdmin(); // Only admins can delete user accounts
    }
    
    // Family Trees collection
    match /familyTrees/{treeId} {
      allow read: if isFamilyMember(treeId) || isAdmin();
      
      allow create: if isAuthenticated() &&
                      isValidFamilyTree(request.resource.data) &&
                      !isRateLimited();
      
      allow update: if (isFamilyMember(treeId) &&
                      resource.data.createdBy == request.auth.uid &&
                      (!request.resource.data.diff(resource.data).hasAny(['createdBy', 'createdAt'])) &&
                      (!('name' in request.resource.data) || 
                       isValidString(request.resource.data.name, 1, 100)) &&
                      (!('region' in request.resource.data) || 
                       isValidString(request.resource.data.region, 0, 100))) ||
                      isAdmin(); // Admins can update any family tree
      
      allow delete: if resource.data.createdBy == request.auth.uid || isAdmin();
      
      // Members subcollection
      match /members/{memberId} {
        allow read: if isFamilyMember(treeId) || isAdmin();
        
        allow create: if (isFamilyMember(treeId) &&
                        isValidPerson(request.resource.data) &&
                        (request.resource.data.createdBy == request.auth.uid || request.resource.data.addedBy == request.auth.uid) &&
                        request.resource.data.createdAt == request.time) ||
                        isAdmin();
        
        allow update: if (isFamilyMember(treeId) &&
                        isValidPerson(request.resource.data) &&
                        (!request.resource.data.diff(resource.data).hasAny(['createdBy', 'createdAt']))) ||
                        isAdmin();
        
        allow delete: if (isFamilyMember(treeId) &&
                        (resource.data.createdBy == request.auth.uid || resource.data.addedBy == request.auth.uid ||
                         get(/databases/$(database)/documents/familyTrees/$(treeId)).data.createdBy == request.auth.uid)) ||
                         isAdmin();
      }
      
      // Stories subcollection
      match /stories/{storyId} {
        allow read: if isFamilyMember(treeId);
        
        allow create: if isFamilyMember(treeId) &&
                        hasRequiredFields(request.resource.data, ['title', 'content', 'authorId']) &&
                        isValidString(request.resource.data.title, 1, 200) &&
                        isValidString(request.resource.data.content, 1, 10000) &&
                        request.resource.data.authorId == request.auth.uid &&
                        request.resource.data.createdAt == request.time;
        
        allow update: if isFamilyMember(treeId) &&
                        resource.data.authorId == request.auth.uid &&
                        (!request.resource.data.diff(resource.data).hasAny(['authorId', 'createdAt']));
        
        allow delete: if resource.data.authorId == request.auth.uid ||
                        get(/databases/$(database)/documents/familyTrees/$(treeId)).data.createdBy == request.auth.uid;
      }
    }
    
    // Invitations collection
    match /invitations/{inviteId} {
      allow read: if isAuthenticated() &&
                    (resource.data.invitedBy == request.auth.uid ||
                     resource.data.email == request.auth.token.email);
      
      allow create: if isAuthenticated() &&
                      hasRequiredFields(request.resource.data, ['email', 'treeId', 'role', 'invitedBy']) &&
                      isValidEmail(request.resource.data.email) &&
                      request.resource.data.role in ['viewer', 'editor'] &&
                      request.resource.data.invitedBy == request.auth.uid &&
                      isFamilyMember(request.resource.data.treeId);
      
      allow update: if isAuthenticated() &&
                      resource.data.email == request.auth.token.email &&
                      request.resource.data.status == 'accepted' &&
                      resource.data.status == 'pending';
      
      allow delete: if resource.data.invitedBy == request.auth.uid;
    }
    
    // Activity logs (read-only for users)
    match /activityLogs/{logId} {
      allow read: if isAuthenticated() &&
                    isFamilyMember(resource.data.treeId);
      allow write: if false; // Only server can write logs
    }
    
    // Admin access logs (write-only for authenticated users, read for admins)
    match /adminAccessLogs/{logId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated();
      allow update, delete: if false;
    }
    
    // Admin activity logs (write-only for admins, read for admins)
    match /adminActivityLogs/{logId} {
      allow read: if isAdmin();
      allow create: if isAdmin();
      allow update, delete: if false;
    }
    
    // Admin logs collection (used by admin dashboard)
    match /admin_logs/{logId} {
      allow read: if isAdmin() || hasRole('superadmin') || hasRole('admin') || hasRole('moderator');
      allow create: if isAdmin() || hasRole('superadmin') || hasRole('admin') || hasRole('moderator');
      allow update, delete: if false; // Logs should be immutable
    }
    
    // Content collection (for content management)
    match /content/{contentId} {
      // Users can read their own content
      allow read: if request.auth != null && 
        (resource.data.userId == request.auth.uid || 
         isAdmin() || hasRole('superadmin') || hasRole('admin') || hasRole('moderator'));
      
      // Users can create content
      allow create: if request.auth != null && 
        request.resource.data.userId == request.auth.uid;
      
      // Users can update their own content, admins can update any content
      allow update: if request.auth != null && 
        (resource.data.userId == request.auth.uid || 
         isAdmin() || hasRole('superadmin') || hasRole('admin'));
      
      // Only admins can delete content
      allow delete: if isAdmin() || hasRole('superadmin') || hasRole('admin');
    }
    
    // Announcements collection (for admin communications)
    match /announcements/{announcementId} {
      // All authenticated users can read published announcements
      allow read: if request.auth != null && 
        (resource.data.status == 'published' || 
         isAdmin() || hasRole('superadmin') || hasRole('admin') || hasRole('moderator'));
      
      // Only admins can create announcements
      allow create: if isAdmin() || hasRole('superadmin') || hasRole('admin');
      
      // Only admins can update announcements
      allow update: if isAdmin() || hasRole('superadmin') || hasRole('admin');
      
      // Only superadmins can delete announcements
      allow delete: if hasRole('superadmin');
    }
    
    // User notifications subcollection
    match /users/{userId}/notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // System/admins can create notifications
      allow create: if request.auth != null && 
        (request.auth.uid == userId || 
         isAdmin() || hasRole('superadmin') || hasRole('admin'));
      
      // Users can update their own notifications (mark as read)
      allow update: if request.auth != null && 
        request.auth.uid == userId &&
        request.resource.data.diff(resource.data).hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // Backups collection (superadmin only)
    match /backups/{backupId} {
      // Only superadmins can read backups
      allow read: if hasRole('superadmin');
      
      // Only system/superadmins can create backups
      allow create: if hasRole('superadmin');
      
      // Only superadmins can update backup metadata
      allow update: if hasRole('superadmin');
      
      // Only superadmins can delete backups
      allow delete: if hasRole('superadmin');
    }
    
    // System configuration collection
    match /system_config/{configId} {
      // Admins can read system config
      allow read: if isAdmin() || hasRole('superadmin') || hasRole('admin');
      
      // Only superadmins can create/update system config
      allow create, update: if hasRole('superadmin');
      
      // Only superadmins can delete system config
      allow delete: if hasRole('superadmin');
    }
    
    // System logs collection
    match /system_logs/{logId} {
      // Admins can read system logs
      allow read: if isAdmin() || hasRole('superadmin') || hasRole('admin');
      
      // System/admins can create logs
      allow create: if isAdmin() || hasRole('superadmin') || hasRole('admin');
      
      // Logs are immutable
      allow update, delete: if false;
    }
    
    // System health collection (for health checks)
    match /system_health/{docId} {
      // Public read for health checks
      allow read: if true;
      
      // Only system can write health data
      allow write: if false;
    }
    
    // Default deny all
    match /{document=**} {
      allow read, write: if false;
    }
  }
}